#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE' >&2
devcontainer helper for this template.

usage:
  cage <repo>            install template, devcontainer up, then tmux
  cage install <repo>    install template only
  cage rebuild <repo>    clear build cache, then up + tmux
  cage exec <repo> -- <cmd>
  cage down <repo>       stop and remove devcontainer
  cage stop <repo>       stop devcontainer
  cage mount <repo> <host_path> <container_path> [--readonly]
  cage upgrade <repo>    update claude/codex/pi inside devcontainer
  cage upgrade-all       update claude/codex/pi in running cage containers

notes:
  - install and default run overwrite .devcontainer in the target repo
  - rebuild keeps named volumes (history, auth) intact
  - set CAGE_TEMPLATE_DIR to override the template source
USAGE
}

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
TEMPLATE_FILES=(Dockerfile devcontainer.json post_install.py)

die() {
  echo "error: $*" >&2
  exit 1
}

normalized_session_name() {
  local base_name
  base_name="$(basename -- "$PWD")"
  printf '%s' "$base_name" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9' '-' | sed 's/^-*//;s/-*$//'
}

ensure_repo() {
  local repo_path="$1"
  [[ -d "$repo_path" ]] || die "repo path does not exist or is not a directory: $repo_path"
}

resolve_repo_path() {
  local repo_path="$1"
  (cd -- "$repo_path" && pwd)
}

find_template_dir() {
  if [[ -n "${CAGE_TEMPLATE_DIR:-}" && -d "$CAGE_TEMPLATE_DIR" ]]; then
    echo "$CAGE_TEMPLATE_DIR"
    return
  fi

  if [[ -f "$SCRIPT_DIR/Dockerfile" && -f "$SCRIPT_DIR/devcontainer.json" ]]; then
    echo "$SCRIPT_DIR"
    return
  fi

  if [[ -f "$SCRIPT_DIR/../share/cage/template/Dockerfile" && -f "$SCRIPT_DIR/../share/cage/template/devcontainer.json" ]]; then
    echo "$SCRIPT_DIR/../share/cage/template"
    return
  fi

  if [[ -f "$SCRIPT_DIR/template/Dockerfile" && -f "$SCRIPT_DIR/template/devcontainer.json" ]]; then
    echo "$SCRIPT_DIR/template"
    return
  fi

  if [[ -d "$HOME/.local/share/cage/template" ]]; then
    echo "$HOME/.local/share/cage/template"
    return
  fi

  die "template dir not found (set CAGE_TEMPLATE_DIR or install template)"
}

extract_mounts_to_file() {
  local devcontainer_path="$1"
  local output_path="$2"

  python3 - "$devcontainer_path" "$output_path" <<'PY'
import json
import sys

def die(msg):
    print(f"error: {msg}", file=sys.stderr)
    sys.exit(1)

if len(sys.argv) != 3:
    die("extract mounts requires source and destination")

src_path, out_path = sys.argv[1:]

try:
    with open(src_path, "r", encoding="utf-8") as fh:
        data = json.load(fh)
except FileNotFoundError:
    sys.exit(0)

mounts = data.get("mounts")
if mounts is None:
    mounts = []
if not isinstance(mounts, list):
    die("mounts must be a JSON array")

for entry in mounts:
    if not isinstance(entry, str):
        die("mounts entries must be strings")

with open(out_path, "w", encoding="utf-8") as fh:
    json.dump(mounts, fh)
PY
}

merge_mounts_from_file() {
  local devcontainer_path="$1"
  local mounts_path="$2"

  python3 - "$devcontainer_path" "$mounts_path" <<'PY'
import json
import sys
from typing import Optional

def die(msg):
    print(f"error: {msg}", file=sys.stderr)
    sys.exit(1)

if len(sys.argv) != 3:
    die("merge mounts requires devcontainer.json and mounts file")

devcontainer_path, mounts_path = sys.argv[1:]

try:
    with open(devcontainer_path, "r", encoding="utf-8") as fh:
        data = json.load(fh)
except FileNotFoundError:
    die(f"devcontainer.json not found: {devcontainer_path}")

try:
    with open(mounts_path, "r", encoding="utf-8") as fh:
        existing_mounts = json.load(fh)
except FileNotFoundError:
    existing_mounts = []

if existing_mounts is None:
    existing_mounts = []
if not isinstance(existing_mounts, list):
    die("existing mounts must be a JSON array")

def parse_target(value: str) -> Optional[str]:
    for part in value.split(","):
        if "=" in part:
            key, val = part.split("=", 1)
            if key == "target":
                return val
    return None

mounts = data.get("mounts")
if mounts is None:
    mounts = []
if not isinstance(mounts, list):
    die("mounts must be a JSON array")

merged = list(mounts)
targets = {}
for idx, entry in enumerate(merged):
    if not isinstance(entry, str):
        die("mounts entries must be strings")
    target = parse_target(entry)
    if target:
        targets[target] = idx

for entry in existing_mounts:
    if not isinstance(entry, str):
        die("existing mounts entries must be strings")
    target = parse_target(entry)
    if target and target in targets:
        merged[targets[target]] = entry
    else:
        merged.append(entry)

data["mounts"] = merged
with open(devcontainer_path, "w", encoding="utf-8") as fh:
    json.dump(data, fh, indent=2)
    fh.write("\n")
PY
}

copy_template() {
  local repo_path="$1"
  local src_dir="$2"
  local dest_dir="$repo_path/.devcontainer"

  mkdir -p "$dest_dir"

  local existing_mounts_file="${3:-}"
  if [[ -z "$existing_mounts_file" && -f "$dest_dir/devcontainer.json" ]]; then
    existing_mounts_file="$(mktemp)"
    extract_mounts_to_file "$dest_dir/devcontainer.json" "$existing_mounts_file"
  fi

  for f in "${TEMPLATE_FILES[@]}"; do
    [[ -f "$src_dir/$f" ]] || die "missing template file: $src_dir/$f"
    cp -f "$src_dir/$f" "$dest_dir/$f"
  done

  if [[ -n "$existing_mounts_file" && -f "$existing_mounts_file" ]]; then
    merge_mounts_from_file "$dest_dir/devcontainer.json" "$existing_mounts_file"
    rm -f "$existing_mounts_file" || true
  fi


  echo "âœ“ devcontainer installed to: $dest_dir" >&2
}

ensure_screenshots_dir() {
  local screenshots_dir

  screenshots_dir="${CAGE_SCREENSHOTS_DIR:-$HOME/Desktop}"
  if [[ "$screenshots_dir" == "~" || "$screenshots_dir" == "~/"* ]]; then
    screenshots_dir="${HOME}${screenshots_dir#\~}"
  fi
  if [[ -e "$screenshots_dir" && ! -d "$screenshots_dir" ]]; then
    die "CAGE_SCREENSHOTS_DIR is not a directory: $screenshots_dir"
  fi
  if [[ ! -d "$screenshots_dir" ]]; then
    die "screenshots dir missing: $screenshots_dir (create it or set CAGE_SCREENSHOTS_DIR)"
  fi
  export CAGE_SCREENSHOTS_DIR="$screenshots_dir"
}

replace_template() {
  local repo_path="$1"
  local src_dir="$2"
  local dest_dir="$repo_path/.devcontainer"
  local existing_mounts_file=""

  if [[ -f "$dest_dir/devcontainer.json" ]]; then
    existing_mounts_file="$(mktemp)"
    extract_mounts_to_file "$dest_dir/devcontainer.json" "$existing_mounts_file"
  fi

  rm -rf "$dest_dir"
  copy_template "$repo_path" "$src_dir" "$existing_mounts_file"
  if [[ -n "$existing_mounts_file" ]]; then
    rm -f "$existing_mounts_file" || true
  fi
}

require_devcontainer_cli() {
  if ! command -v devcontainer >/dev/null 2>&1; then
    if [[ -n "${NVM_DIR:-}" && -s "$NVM_DIR/nvm.sh" ]]; then
      # Allow non-interactive shells to find devcontainer via nvm.
      # shellcheck source=/dev/null
      . "$NVM_DIR/nvm.sh"
    elif [[ -s "$HOME/.nvm/nvm.sh" ]]; then
      # shellcheck source=/dev/null
      . "$HOME/.nvm/nvm.sh"
    fi
  fi

  if ! command -v devcontainer >/dev/null 2>&1; then
    echo "error: devcontainer cli not found" >&2
    echo "hint: npm install -g @devcontainers/cli" >&2
    exit 1
  fi
}

require_docker_cli() {
  if ! command -v docker >/dev/null 2>&1; then
    echo "error: docker cli not found" >&2
    echo "hint: install Docker Desktop or OrbStack" >&2
    exit 1
  fi
}

install_tools() {
  local repo_path="$1"

  devcontainer exec --workspace-folder "$repo_path" npm install -g \
    @anthropic-ai/claude-code \
    @openai/codex \
    @mariozechner/pi-coding-agent
}

list_running_cage_repos() {
  local containers=""

  containers="$(docker ps --filter "label=cage.managed=true" -q)"
  if [[ -z "$containers" ]]; then
    return 0
  fi

  local container=""
  for container in $containers; do
    local repo_path=""
    repo_path="$(docker inspect -f '{{ index .Config.Labels "devcontainer.local_folder" }}' "$container" 2>/dev/null || true)"
    if [[ -z "$repo_path" || "$repo_path" == "<no value>" ]]; then
      continue
    fi
    echo "$repo_path"
  done
}

upgrade_repo() {
  local repo_path="$1"

  copy_template "$repo_path" "$TEMPLATE_DIR"
  ensure_screenshots_dir
  require_devcontainer_cli
  devcontainer up --workspace-folder "$repo_path"
  install_tools "$repo_path"
}

update_devcontainer_mounts() {
  local devcontainer_path="$1"
  local host_path="$2"
  local container_path="$3"
  local readonly="$4"

  python3 - "$devcontainer_path" "$host_path" "$container_path" "$readonly" <<'PY'
import json
import os
import sys
from typing import Optional

def die(msg):
    print(f"error: {msg}", file=sys.stderr)
    sys.exit(1)

if len(sys.argv) != 5:
    die("update_devcontainer_mounts requires 4 arguments")

devcontainer_path, host_path, container_path, readonly = sys.argv[1:]

if readonly not in ("true", "false"):
    die("readonly must be true or false")

if not os.path.isabs(host_path):
    die(f"host path must be absolute: {host_path}")
if not os.path.isdir(host_path):
    die(f"host path is not a directory: {host_path}")
if not os.path.isabs(container_path):
    die(f"container path must be absolute: {container_path}")

try:
    with open(devcontainer_path, "r", encoding="utf-8") as fh:
        data = json.load(fh)
except FileNotFoundError:
    die(f"devcontainer.json not found: {devcontainer_path}")

mounts = data.get("mounts")
if mounts is None:
    mounts = []
if not isinstance(mounts, list):
    die("mounts must be a JSON array")

for entry in mounts:
    if not isinstance(entry, str):
        die("mounts entries must be strings")

mount_entry = f"source={host_path},target={container_path},type=bind,consistency=cached"
if readonly == "true":
    mount_entry += ",readonly"

def parse_target(value: str) -> Optional[str]:
    for part in value.split(","):
        if "=" in part:
            key, val = part.split("=", 1)
            if key == "target":
                return val
    return None

new_mounts = []
replaced = False
for entry in mounts:
    target = parse_target(entry)
    if target == container_path:
        if not replaced:
            new_mounts.append(mount_entry)
            replaced = True
        continue
    new_mounts.append(entry)

if not replaced:
    new_mounts.append(mount_entry)

data["mounts"] = new_mounts
with open(devcontainer_path, "w", encoding="utf-8") as fh:
    json.dump(data, fh, indent=2)
    fh.write("\n")
PY
}

main() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 1
  fi

  cmd="$1"
  shift

  local needs_repo="true"

  case "$cmd" in
    help|-h|--help)
      usage
      exit 0
      ;;
    install|rebuild|exec|upgrade|mount|down|stop)
      ;;
    upgrade-all)
      needs_repo="false"
      ;;
    *)
      set -- "$cmd" "$@"
      cmd="up"
      ;;
  esac

  TEMPLATE_DIR="$(find_template_dir)"

  if [[ "$needs_repo" == "true" ]]; then
    if [[ $# -lt 1 ]]; then
      usage
      exit 1
    fi

    REPO_PATH="$1"
    shift

    ensure_repo "$REPO_PATH"
    REPO_PATH="$(resolve_repo_path "$REPO_PATH")"
    TMUX_SESSION="$(normalized_session_name)"
  elif [[ $# -gt 0 ]]; then
    usage
    exit 1
  fi

  case "$cmd" in
    install)
      copy_template "$REPO_PATH" "$TEMPLATE_DIR"
      exit 0
      ;;
    rebuild)
      replace_template "$REPO_PATH" "$TEMPLATE_DIR"
      ensure_screenshots_dir
      require_devcontainer_cli
      devcontainer up --workspace-folder "$REPO_PATH" --remove-existing-container --build-no-cache
      devcontainer exec --workspace-folder "$REPO_PATH" tmux new -As "$TMUX_SESSION"
      ;;
    up)
      copy_template "$REPO_PATH" "$TEMPLATE_DIR"
      ensure_screenshots_dir
      require_devcontainer_cli
      devcontainer up --workspace-folder "$REPO_PATH"
      devcontainer exec --workspace-folder "$REPO_PATH" tmux new -As "$TMUX_SESSION"
      ;;
    exec)
      copy_template "$REPO_PATH" "$TEMPLATE_DIR"
      ensure_screenshots_dir
      require_devcontainer_cli
      if [[ $# -gt 0 && "$1" == "--" ]]; then
        shift
      fi
      [[ $# -gt 0 ]] || die "exec requires a command"
      devcontainer exec --workspace-folder "$REPO_PATH" "$@"
      ;;
    upgrade)
      upgrade_repo "$REPO_PATH"
      ;;
    upgrade-all)
      require_docker_cli
      local repo_paths=()
      local repo_path=""

      while IFS= read -r repo_path; do
        [[ -z "$repo_path" ]] && continue
        repo_paths+=("$repo_path")
      done < <(list_running_cage_repos)

      if [[ ${#repo_paths[@]} -eq 0 ]]; then
        echo "no running cage containers found" >&2
        exit 0
      fi

      for repo_path in "${repo_paths[@]}"; do
        if [[ ! -d "$repo_path" ]]; then
          echo "warning: repo path missing: $repo_path" >&2
          continue
        fi
        repo_path="$(resolve_repo_path "$repo_path")"
        upgrade_repo "$repo_path"
      done
      ;;
    down)
      require_docker_cli
      local label="devcontainer.local_folder=$REPO_PATH"
      local containers=""

      containers="$(docker ps -a --filter "label=$label" -q)"
      if [[ -z "$containers" ]]; then
        echo "no devcontainer found for: $REPO_PATH" >&2
        exit 0
      fi

      docker rm -f $containers
      ;;
    stop)
      require_docker_cli
      local label="devcontainer.local_folder=$REPO_PATH"
      local containers=""

      containers="$(docker ps --filter "label=$label" -q)"
      if [[ -z "$containers" ]]; then
        containers="$(docker ps -a --filter "label=$label" -q)"
        if [[ -z "$containers" ]]; then
          echo "no devcontainer found for: $REPO_PATH" >&2
          exit 0
        fi
        echo "devcontainer already stopped for: $REPO_PATH" >&2
        exit 0
      fi

      docker stop $containers
      ;;
    mount)
      local host_path=""
      local container_path=""
      local readonly="false"

      host_path="${1:-}"
      container_path="${2:-}"
      shift 2 || true

      if [[ -z "$host_path" || -z "$container_path" ]]; then
        die "mount requires <host_path> <container_path> [--readonly]"
      fi

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --readonly)
            readonly="true"
            shift
            ;;
          *)
            die "unknown mount option: $1"
            ;;
        esac
      done

      if [[ ! -f "$REPO_PATH/.devcontainer/devcontainer.json" ]]; then
        copy_template "$REPO_PATH" "$TEMPLATE_DIR"
      fi

      update_devcontainer_mounts "$REPO_PATH/.devcontainer/devcontainer.json" "$host_path" "$container_path" "$readonly"
      ensure_screenshots_dir
      require_devcontainer_cli
      devcontainer up --workspace-folder "$REPO_PATH" --remove-existing-container
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  main "$@"
fi
